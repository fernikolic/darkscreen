#!/usr/bin/env node

/**
 * build-screen-analysis.mjs
 *
 * Reads extracted JSON files from public/screenshots/ and generates
 * src/data/screen-analysis.ts — a flat TypeScript data module keyed
 * by screenshot image path.
 *
 * Usage:
 *   node scripts/build-screen-analysis.mjs
 *   node scripts/build-screen-analysis.mjs --dry-run
 */

import { readdirSync, readFileSync, writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { parseArgs } from "util";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");
const SCREENSHOTS_DIR = join(ROOT, "public", "screenshots");
const OUTPUT_PATH = join(ROOT, "src", "data", "screen-analysis.ts");

const { values: flags } = parseArgs({
  options: {
    "dry-run": { type: "boolean", default: false },
  },
});

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function safe(val, fallback) {
  return val !== undefined && val !== null ? val : fallback;
}

function safeArray(val) {
  return Array.isArray(val) ? val : [];
}

function extractAnalysis(screen) {
  const design = screen.design || {};
  const flow = screen.flow || {};
  const copy = screen.copy || {};

  return {
    screenType: safe(flow.screenType, ""),
    userIntent: safe(flow.userIntent, ""),
    interactiveElements: safeArray(flow.interactiveElements).map((el) => ({
      element: safe(el.element, ""),
      action: safe(el.action, ""),
    })),
    frictionPoints: safeArray(flow.frictionPoints),
    progressIndicators: safeArray(flow.progressIndicators),
    designLayout: safe(design.layout, ""),
    colorScheme: safe(design.colorScheme, ""),
    components: safeArray(design.components).map((c) => ({
      type: safe(c.type, ""),
      description: safe(c.description, ""),
      position: safe(c.position, ""),
      notable: safe(c.notable, ""),
    })),
    headline: safe(copy.headline, ""),
    ctas: safeArray(copy.ctas).map((cta) => ({
      text: safe(cta.text, ""),
      style: safe(cta.style, ""),
      placement: safe(cta.placement, ""),
    })),
  };
}

function escapeForTS(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

function serializeValue(val, indent) {
  if (typeof val === "string") {
    return `"${escapeForTS(val)}"`;
  }
  if (Array.isArray(val)) {
    if (val.length === 0) return "[]";
    const items = val.map((item) => serializeValue(item, indent + "  "));
    return `[\n${items.map((i) => `${indent}    ${i}`).join(",\n")}\n${indent}  ]`;
  }
  if (typeof val === "object" && val !== null) {
    const entries = Object.entries(val);
    if (entries.length === 0) return "{}";
    const lines = entries.map(
      ([k, v]) => `${indent}  ${k}: ${serializeValue(v, indent + "  ")}`
    );
    return `{\n${lines.join(",\n")}\n${indent}}`;
  }
  return String(val);
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

const files = readdirSync(SCREENSHOTS_DIR).filter((f) =>
  f.endsWith("-extracted.json")
);

console.log(`Processing ${files.length} extracted files...`);

const analyses = {};
let totalScreens = 0;

for (const file of files) {
  const raw = readFileSync(join(SCREENSHOTS_DIR, file), "utf-8");
  let data;
  try {
    data = JSON.parse(raw);
  } catch {
    console.warn(`  Skipping ${file} — invalid JSON`);
    continue;
  }

  if (!data.totalScreens || data.totalScreens === 0) {
    continue;
  }

  for (const screen of safeArray(data.screens)) {
    if (!screen.image) continue;
    analyses[screen.image] = extractAnalysis(screen);
    totalScreens++;
  }
}

console.log(`Generated analysis for ${totalScreens} screens`);

// ---------------------------------------------------------------------------
// Build output
// ---------------------------------------------------------------------------

const lines = [
  "// Auto-generated by scripts/build-screen-analysis.mjs — do not edit manually",
  "",
  "export interface ScreenAnalysis {",
  "  screenType: string;",
  "  userIntent: string;",
  "  interactiveElements: { element: string; action: string }[];",
  "  frictionPoints: string[];",
  "  progressIndicators: string[];",
  "  designLayout: string;",
  "  colorScheme: string;",
  "  components: { type: string; description: string; position: string; notable: string }[];",
  "  headline: string;",
  "  ctas: { text: string; style: string; placement: string }[];",
  "}",
  "",
  "export const screenAnalysis: Record<string, ScreenAnalysis> = {",
];

const keys = Object.keys(analyses).sort();
for (const key of keys) {
  const a = analyses[key];
  lines.push(`  "${escapeForTS(key)}": {`);
  lines.push(`    screenType: "${escapeForTS(a.screenType)}",`);
  lines.push(`    userIntent: "${escapeForTS(a.userIntent)}",`);

  // interactiveElements
  if (a.interactiveElements.length === 0) {
    lines.push(`    interactiveElements: [],`);
  } else {
    lines.push(`    interactiveElements: [`);
    for (const el of a.interactiveElements) {
      lines.push(
        `      { element: "${escapeForTS(el.element)}", action: "${escapeForTS(el.action)}" },`
      );
    }
    lines.push(`    ],`);
  }

  // frictionPoints
  if (a.frictionPoints.length === 0) {
    lines.push(`    frictionPoints: [],`);
  } else {
    lines.push(`    frictionPoints: [`);
    for (const fp of a.frictionPoints) {
      lines.push(`      "${escapeForTS(fp)}",`);
    }
    lines.push(`    ],`);
  }

  // progressIndicators
  if (a.progressIndicators.length === 0) {
    lines.push(`    progressIndicators: [],`);
  } else {
    lines.push(`    progressIndicators: [`);
    for (const pi of a.progressIndicators) {
      lines.push(`      "${escapeForTS(pi)}",`);
    }
    lines.push(`    ],`);
  }

  lines.push(`    designLayout: "${escapeForTS(a.designLayout)}",`);
  lines.push(`    colorScheme: "${escapeForTS(a.colorScheme)}",`);

  // components
  if (a.components.length === 0) {
    lines.push(`    components: [],`);
  } else {
    lines.push(`    components: [`);
    for (const c of a.components) {
      lines.push(
        `      { type: "${escapeForTS(c.type)}", description: "${escapeForTS(c.description)}", position: "${escapeForTS(c.position)}", notable: "${escapeForTS(c.notable)}" },`
      );
    }
    lines.push(`    ],`);
  }

  lines.push(`    headline: "${escapeForTS(a.headline)}",`);

  // ctas
  if (a.ctas.length === 0) {
    lines.push(`    ctas: [],`);
  } else {
    lines.push(`    ctas: [`);
    for (const cta of a.ctas) {
      lines.push(
        `      { text: "${escapeForTS(cta.text)}", style: "${escapeForTS(cta.style)}", placement: "${escapeForTS(cta.placement)}" },`
      );
    }
    lines.push(`    ],`);
  }

  lines.push(`  },`);
}

lines.push("};");
lines.push("");

const output = lines.join("\n");

if (flags["dry-run"]) {
  console.log("[dry-run] Would write to", OUTPUT_PATH);
  console.log(`[dry-run] Output: ${output.length} chars, ${keys.length} entries`);
} else {
  writeFileSync(OUTPUT_PATH, output, "utf-8");
  console.log(`Written to src/data/screen-analysis.ts`);
}
